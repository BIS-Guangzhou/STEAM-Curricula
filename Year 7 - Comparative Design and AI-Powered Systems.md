### **Year 7 STEAM Curriculum: Comparative Design and AI-Powered Systems** üöÄ

#### **Curriculum Summary** üåü

This 15-class STEAM program is designed for Year 7 students, aligning with the Cambridge Lower Secondary framework and building on their established skills in Python, robotics, and digital design. The curriculum centers on the NGSS standard **MS-ETS1-2**: **"Evaluate competing design solutions using a systematic process to determine how well they meet the criteria and constraints of the problem"**. Each 90-minute class is structured with a 60-minute main lesson and a 30-minute hands-on extension, utilizing the 5E instructional model (Engage, Explore, Explain, Elaborate, Evaluate) to foster deep learning and engagement.

Students will advance their text-based programming skills in **Python**, manage and analyze data more rigorously, and explore the practical applications and ethical dimensions of Artificial Intelligence. The core of this curriculum is to develop a systematic process for comparing multiple potential solutions to a single problem, using data-driven evidence to justify design choices and understand trade-offs.

***

### **Unit 1: Advanced Systems and Data Management (Classes 1-3)** üíª

#### **Class 1: Object-Oriented Concepts in Python** üß©

*   **Main Class (60 min):**
    *   **Engage**: Show two robots that perform similar tasks but are programmed differently: one with a long script, the other with organized, reusable code. Ask: "Which design is better for complex, long-term projects?".
    *   **Explore**: In Python, students will define a simple `class` (e.g., a `Robot` class) with basic attributes (e.g., `name`, `speed`) and methods (e.g., `move_forward()`). They will then create multiple "objects" from this class.
    *   **Explain**: Introduce the fundamental concepts of **Object-Oriented Programming (OOP)**, explaining that classes act as blueprints for creating objects. Discuss how this approach helps manage complexity in large-scale software and robotics projects.
    *   **Elaborate**: Students refactor a procedural Python script for robot control into a simple class structure, making the code more modular and reusable.
    *   **Evaluate**: Review students‚Äô code for correct class and object implementation, providing formative feedback on their understanding of OOP principles.
*   **Robot Extension (30 min):**
    *   Students create two robot objects from their `Robot` class in Python, each with different speed attributes. They then command both robots to perform the same task, demonstrating how OOP allows for the easy management of multiple, distinct agents.

#### **Class 2: Introduction to Data Structures** üåê

*   **Main Class (60 min):**
    *   **Engage**: Ask students how a social media app efficiently stores a user's list of friends or how a game manages an inventory of items.
    *   **Explore**: Students use Python to store data in different **data structures**: lists, tuples, and dictionaries. They perform basic operations like adding, removing, and accessing elements in each.
    *   **Explain**: Explain the unique properties and use cases for each data structure (e.g., lists are mutable, dictionaries use key-value pairs for fast lookups). Discuss how choosing the right data structure is a critical part of efficient programming.
    *   **Elaborate**: Students write a Python program to manage a collection of data, such as a simple inventory for a game, and must choose the most appropriate data structure to store and manipulate the information.
    *   **Evaluate**: Assess students' programs to see if they chose a logical data structure and can justify their decision based on the task's requirements.
*   **Robot Extension (30 min):**
    *   Students program a robot to follow a path defined by a sequence of commands stored in a list (e.g., `['forward', 'left', 'forward']`). They then experiment with changing the list to alter the robot's path, demonstrating how data structures can dynamically control hardware behavior.

#### **Class 3: Version Control and Collaborative Design** üßä

*   **Main Class (60 min):**
    *   **Engage**: Pose a scenario: "Two programmers are working on the same code file. How do they merge their changes without accidentally deleting each other's work?"
    *   **Explore**: Using a simplified, visual tool or a shared document with version history, students work in pairs on the same text. They experience the challenge of overwriting changes and the benefit of being able to revert to a previous version.
    *   **Explain**: Introduce the concept of **version control** as a system that tracks changes to files over time, allowing for collaboration and error recovery. Mention tools like Git and platforms like GitHub as industry standards.
    *   **Elaborate**: Students collaborate on a shared 3D design file or a Python script, practicing a simple workflow of making changes, leaving comments for their partner, and reviewing updates.
    *   **Evaluate**: Through observation, assess students' ability to work collaboratively on a shared digital artifact, providing feedback on their communication and workflow.
*   **Robot Extension (30 min):**
    *   Two teams are given the same base robot code but are tasked with developing different features (e.g., one adds sound, the other adds a light). They then work together to merge their code into a single, functional program, simulating a collaborative development cycle.

***

### **Unit 2: Evaluating Competing Solutions and Prototyping (Classes 4-7)** ü§ñ

#### **Class 4: Generating and Comparing Multiple Solutions (MS-ETS1-2 Focus)** üéØ

*   **Main Class (60 min):**
    *   **Engage**: Present a defined problem from the previous year (e.g., a robot to collect litter). Ask: "Is there only one 'right' way to solve this? What are some completely different approaches we could take?".
    *   **Explore**: For a given design problem, groups brainstorm and sketch **two or three distinct competing solutions**. For example, a litter-collecting robot could use a scoop, a claw, or a suction mechanism. They list the potential strengths and weaknesses of each idea.
    *   **Explain**: Formally introduce **MS-ETS1-2**. Explain that engineering often involves comparing multiple valid solutions against the defined criteria and constraints to find the most optimal one. Introduce the concept of a **decision matrix** as a systematic tool for evaluation.
    *   **Elaborate**: Each group creates a decision matrix to compare their brainstormed solutions. They score each design concept against the project's criteria (e.g., speed, collection capacity, reliability) and constraints (e.g., cost, complexity) to systematically identify a lead candidate.
    *   **Evaluate**: Assess the groups' decision matrices for logical criteria and a systematic, evidence-based approach to comparing their competing designs.
*   **Robot Extension (30 min):**
    *   Groups build simple, non-functional physical mock-ups of their top two competing design ideas using basic materials. This helps them visualize the physical differences and refine their assessment of strengths and weaknesses.

#### **Class 5: Prototyping Competing Software Solutions in Python** üìä

*   **Main Class (60 min):**
    *   **Engage**: "We've compared ideas on paper. How can we quickly test two different software approaches to see which one actually works better?"
    *   **Explore**: Students are given a task, such as sorting a list of items for the robot to collect. They will code two different algorithms in Python to accomplish this: one simple (e.g., a basic linear search) and one slightly more complex but potentially more efficient.
    *   **Explain**: Discuss the concept of **software prototyping**‚Äîcreating simplified versions of different programming solutions to test their logic and performance before fully integrating them. This connects to the "Evaluate competing solutions" standard.
    *   **Elaborate**: Students run both of their algorithms with test data and gather performance metrics (e.g., execution time, number of steps). They use this data to compare the two software solutions empirically.
    *   **Evaluate**: Review students' code and their collected data, providing feedback on their ability to implement and quantitatively compare two different algorithmic approaches.
*   **Robot Extension (30 min):**
    *   Students load both of their prototype algorithms onto a robot and run them. They observe the physical difference in the robot's performance (e.g., one algorithm makes the robot pause longer while 'thinking'), providing a tangible demonstration of algorithmic efficiency.

#### **Class 6: Prototyping Competing Physical Designs with 3D Printing** üìà

*   **Main Class (60 min):**
    *   **Engage**: Show two different 3D-printed mechanical parts for the same function, like two types of gears. Ask: "How would we decide which design is stronger or more efficient without just guessing?".
    *   **Explore**: Based on the evaluation in Class 4, groups select their top **two competing physical designs** (e.g., a robot claw vs. a scoop). They create simplified 3D models of both prototypes, focusing on the core functional differences.
    *   **Explain**: Explain that **rapid prototyping** with tools like 3D printing allows engineers to create and test physical versions of competing solutions quickly. Discuss how to design fair tests to compare these physical prototypes.
    *   **Elaborate**: Groups prepare both of their competing designs in slicing software and begin printing them. They design a specific, measurable test to compare the performance of the two parts once they are printed (e.g., "Which design can lift the heaviest object?").
    *   **Evaluate**: Assess the fairness and clarity of the students' test plans, ensuring they are designed to produce quantitative data for comparing the two physical solutions.
*   **Robot Extension (30 min):**
    *   Students attach their two different 3D-printed prototypes to a standardized robot chassis. They then conduct their planned physical tests, collecting data (e.g., weight lifted, time to grip) for both designs to use for their final evaluation.

#### **Class 7: Final Solution Selection and Justification** üêç

*   **Main Class (60 min):**
    *   **Engage**: "You have data from your software tests and your physical tests. Now it's time to make a final, evidence-based decision."
    *   **Explore**: Groups combine all their quantitative and qualitative data from the software and hardware tests. They update their decision matrix from Class 4 with this new empirical evidence.
    *   **Explain**: Reiterate the importance of using a **systematic process** to evaluate solutions, as required by **MS-ETS1-2**. Explain that the final choice should be justifiable through a clear analysis of the test data and how it relates to the project's criteria and constraints.
    *   **Elaborate**: Each group writes a "Design Choice Justification" report. In it, they formally select their final design (which may be a hybrid of their ideas) and use their data and decision matrix to defend why it is the optimal solution for the problem.
    *   **Evaluate**: Assess the justification reports for a clear, logical, and data-driven argument that systematically evaluates the competing solutions.
*   **Robot Extension (30 min):**
    *   Groups assemble and program their single, chosen design into its final prototype form. This session is dedicated to building the "production model" based on their rigorous evaluation process, preparing it for the final challenge.

***

### **Unit 3: AI Systems and Advanced Applications (Classes 8-11)** üîß

*Classes 8-11 follow the same titles as the Year 6 curriculum, but with more advanced content reflecting the students' progression.*

#### **Class 8: Preparing and Printing 3D Designs** üñ®Ô∏è
#### **Class 9: Assembling and Integrating Complex Systems** üî©
#### **Class 10: Advanced Debugging and System Optimization** üîÑ
#### **Class 11: Final Showcase and Constructive Peer Critique** üé§

***

### **Unit 4: Future Technologies and Global Impact (Classes 12-15)** üé®

#### **Class 12: AI Ethics and Algorithmic Bias** üåê

*   **Main Class (60 min):**
    *   **Engage**: Discuss a real-world case of AI bias, such as a facial recognition system that performs poorly on certain demographics. Ask: "Who is responsible when an AI makes an unfair decision?".
    *   **Explore**: Using an educational tool, students interact with an AI model trained on a biased dataset. They observe how the bias in the input data leads to flawed or unfair outputs.
    *   **Explain**: Provide a deeper explanation of **algorithmic bias**, discussing how it can unintentionally arise from skewed data or flawed assumptions in an algorithm's design. Discuss the ethical imperative for fairness and transparency in AI systems.
    *   **Elaborate**: Students research and present on a specific ethical challenge in AI (e.g., data privacy, job automation, autonomous weapons). They must propose one strategy to help mitigate the ethical risks.
    *   **Evaluate**: Assess the students‚Äô presentations for their understanding of the ethical issue and the thoughtfulness of their proposed mitigation strategy.
*   **Robot Extension (30 min):**
    *   Students program a robot with a simple "hiring algorithm" to select candidate blocks based on a certain property (e.g., color). They then intentionally feed it a biased set of "training" blocks and watch as it makes discriminatory "hiring" choices, creating a tangible model of algorithmic bias.

#### **Class 13: Introduction to Machine Learning Concepts** üéÆ

*   **Main Class (60 min):**
    *   **Engage**: Ask: "How does your email spam filter learn to identify new types of junk mail automatically?".
    *   **Explore**: Using a platform like **Code.org's AI library** or another interactive tool, students train a simple **machine learning (ML)** model for classification (e.g., teaching it to distinguish between pictures of cats and dogs).
    *   **Explain**: Explain the basic concept of **machine learning** as a subset of AI where systems learn directly from data to make predictions or decisions. Differentiate between training a model and explicitly programming it with rules.
    *   **Elaborate**: Students experiment with the quantity and quality of training data they provide to the ML model and analyze how it impacts the model's prediction accuracy, reinforcing the idea that data is the foundation of modern AI.
    *   **Evaluate**: Through guided discussion, assess students' understanding that ML models "learn" from data and that the quality of this data directly affects performance.
*   **Robot Extension (30 min):**
    *   Students use a robot with a color sensor to gather data on different colored objects. They use this data to manually "train" a simple decision tree in their Python code that allows the robot to predict the color of a new object it has never seen before, simulating a basic ML classification task.

#### **Class 14: AI in the Real World: APIs and Agentic Systems** üß†

*   **Main Class (60 min):**
    *   **Engage**: Show a demonstration of a modern AI assistant like Claude or a similar agentic LLM completing a coding task. Discuss how these systems can understand goals and take actions.
    *   **Explore**: Students use a simple, pre-existing Python script that calls a public **API** (Application Programming Interface), such as a weather API, to retrieve and display real-world data.
    *   **Explain**: Explain that APIs allow different software systems to communicate and share data. Discuss how modern **agentic AI** systems use tools (often via APIs) to interact with the world, complete tasks, and access up-to-date information.
    *   **Elaborate**: Students modify their Python script to parse the API data and make a decision based on it (e.g., "If the temperature is above 25¬∞C, print 'It is a hot day!'"). This simulates a basic agentic action.
    *   **Evaluate**: Review students' scripts for their ability to successfully call an API and use the returned data to trigger a logical action.
*   **Robot Extension (30 min):**
    *   Students connect their robot's Python script to the weather API. They program the robot to perform a different physical action based on the real-time weather data (e.g., spin happily if it's sunny, make a sad sound if it's raining), creating a simple, data-responsive agent.

#### **Class 15: Future-Ready Innovation Expo** üéâ

*   **Main Class (60 min):**
    *   **Engage**: Frame the showcase as a "Comparative Design Review," where students present not just their final product, but their evaluation process for choosing it over other options.
    *   **Explore**: Students present their final projects, emphasizing the **MS-ETS1-2** standard. They must showcase the competing solutions they considered and present the data that justifies their final design choice.
    *   **Explain**: Facilitate a reflection on how a systematic evaluation process leads to more robust and well-thought-out solutions. Connect their experience to real-world engineering where justifying decisions with data is critical.
    *   **Elaborate**: Students participate in a Q&A session, defending their design choices with evidence and providing constructive feedback to peers on the rigor of their evaluation process.
    *   **Evaluate**: A final formative assessment celebrating students' ability to systematically evaluate competing solutions, iterate, and reflect on a complex engineering problem, consistent with the Cambridge assessment approach.
*   **Robot Extension (30 min):**
    *   The expo concludes with a final demonstration of each team's chosen robotic solution. This live run serves as the ultimate proof of their design, testing, and systematic evaluation journey.